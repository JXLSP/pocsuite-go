package shellcodes

import (
	"bytes"
)

type ExeBuilder struct {
	osTarget OS
	osArch   Arch
}

func NewExeBuilder(osTarget OS, osArch Arch) *ExeBuilder {
	return &ExeBuilder{
		osTarget: osTarget,
		osArch:   osArch,
	}
}

func (eb *ExeBuilder) Build(shellcode []byte) ([]byte, error) {
	switch eb.osTarget {
	case Windows:
		return eb.buildWindowsExe(shellcode)
	case Linux:
		return eb.buildLinuxExe(shellcode)
	default:
		return nil, nil
	}
}

func (eb *ExeBuilder) buildWindowsExe(shellcode []byte) ([]byte, error) {
	switch eb.osArch {
	case Arch32:
		return eb.buildWindowsX86Exe(shellcode)
	case Arch64:
		return eb.buildWindowsX64Exe(shellcode)
	default:
		return nil, nil
	}
}

func (eb *ExeBuilder) buildLinuxExe(shellcode []byte) ([]byte, error) {
	switch eb.osArch {
	case Arch32:
		return eb.buildLinuxX86Exe(shellcode)
	case Arch64:
		return eb.buildLinuxX64Exe(shellcode)
	default:
		return nil, nil
	}
}

func (eb *ExeBuilder) buildWindowsX86Exe(shellcode []byte) ([]byte, error) {
	header := []byte{
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, // MZ header
		0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
		0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
		0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
		0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
		0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
		0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
		0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
		0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	peHeader := []byte{
		0x50, 0x45, 0x00, 0x00, // PE\0\0
		0x4C, 0x01, 0x02, 0x00, // Machine: i386
	}

	var buf bytes.Buffer
	buf.Write(header)
	buf.Write(peHeader)
	buf.Write(shellcode)
	buf.Write([]byte{0xFF, 0xFF, 0xFF, 0xFF})

	data := buf.Bytes()
	for len(data) < 1536 {
		data = append(data, 0x00)
	}

	return data[:1536], nil
}

func (eb *ExeBuilder) buildWindowsX64Exe(shellcode []byte) ([]byte, error) {
	header := []byte{
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, // MZ header
		0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
		0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
		0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
		0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
		0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
		0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
		0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
		0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	peHeader := []byte{
		0x50, 0x45, 0x00, 0x00, // PE\0\0
		0x64, 0x86, 0x02, 0x00, // Machine: AMD64
	}

	var buf bytes.Buffer
	buf.Write(header)
	buf.Write(peHeader)
	buf.Write(shellcode)
	buf.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
	buf.Write([]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})
	buf.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
	buf.Write([]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})

	data := buf.Bytes()
	for len(data) < 2048 {
		data = append(data, 0x00)
	}

	return data[:2048], nil
}

func (eb *ExeBuilder) buildLinuxX86Exe(shellcode []byte) ([]byte, error) {
	// ELF header for Linux x86
	header := []byte{
		0x7F, 0x45, 0x4C, 0x46, // \x7fELF
		0x01, // 32-bit
		0x01, // little endian
		0x01, // ELF version
		0x00, // System V ABI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x03, 0x00, // Executable, x86
		0x01, 0x00, 0x00, 0x00, // Version
		0x60, 0x80, 0x04, 0x08, // Entry point
		0x34, 0x00, 0x00, 0x00, // Program header offset
		0x00, 0x00, 0x00, 0x00, // Section header offset
		0x00, 0x00, 0x00, 0x00, // Flags
		0x00, 0x00, 0x00, 0x00, // Header size
		0x34, 0x00, 0x00, 0x00, // Program header entry size
		0x00, 0x01, 0x00, 0x00, // Program header count
		0x00, 0x00, 0x00, 0x00, // Section header entry size
		0x00, 0x00, 0x00, 0x00, // Section header count
		0x00, 0x00, 0x00, 0x00, // Section header string table index
	}

	var buf bytes.Buffer
	buf.Write(header)
	buf.Write(shellcode)

	return buf.Bytes(), nil
}

func (eb *ExeBuilder) buildLinuxX64Exe(shellcode []byte) ([]byte, error) {
	// ELF header for Linux x64
	header := []byte{
		0x7F, 0x45, 0x4C, 0x46, // \x7fELF
		0x02, // 64-bit
		0x01, // little endian
		0x01, // ELF version
		0x00, // System V ABI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x3E, 0x00, // Executable, x86-64
		0x01, 0x00, 0x00, 0x00, // Version
		0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // Entry point
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Program header offset
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Section header offset
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Flags
		0x40, 0x00, 0x38, 0x00, // Header size
		0x00, 0x01, 0x00, 0x00, // Program header entry size
		0x00, 0x01, 0x00, 0x00, // Program header count
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Section header entry size
		0x00, 0x00, 0x00, 0x00, // Section header count
		0x00, 0x00, 0x00, 0x00, // Section header string table index
	}

	var buf bytes.Buffer
	buf.Write(header)
	buf.Write(shellcode)

	return buf.Bytes(), nil
}
